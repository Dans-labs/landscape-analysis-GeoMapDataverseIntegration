<!-- START of custom footer content -->
<style>
        /* NOTE: CSS has been moved to custom-stylesheet.css file */
</style>
<div id="custom-footer">
    <div class="container">
        <div class="row">
            <!-- Start of row content -->
            <div class="col-lg-3 col-md-3 col-sm-6">
                <div class="h1">Contact and Support</div>
                <ul class="services">
                    <li><a href="https://dans.knaw.nl/en/contact/" target="_blank">Contact</a></li>
                    <li><a href="https://dans.knaw.nl/en/using-data-stations/" target="_blank">Using the Services</a></li>
                    <li><a href="https://dans.knaw.nl/en/legal-information/" target="_blank">Legal Information</a></li>
                    <li><a href="https://dans.knaw.nl/en/privacy-declaration/" target="_blank">Privacy</a></li>
                    <li><a href="https://dans.knaw.nl/en/disclaimer/" target="_blank">Disclaimer</a></li>
                </ul>
            </div>
            <div class="col-lg-3 col-md-3 col-sm-6">
                <div class="h1">About DANS</div>
                <ul>
                    <li><a href="https://dans.knaw.nl/en/about/" target="_blank">Mission</a></li>
                    <li><a href="https://dans.knaw.nl/en/about/team/" target="_blank">Our Team</a></li>
                    <li><a href="https://dans.knaw.nl/en/working-for-dans/"  target="_blank">Working for DANS</a></li>
                </ul>
            </div>
            <div class="col-lg-3 col-md-3 col-sm-6">
                <div class="h1">Follow Us</div>
                <ul>
                    <li>
                        <a href="https://dans.email-provider.eu/memberforms/subscribe/standalone/form/?a=vzl9su9xiv&amp;l=yy3ox9lfh8" target="_blank">
                                <span class="footer_icons nieuwsbrief">
                                    <img src="/logos/branding/letter.svg"/>
                                    Newsletter DataLink
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://www.youtube.com/user/DANSDataArchiving" target="_blank">
                                <span class="footer_icons">
                                    <img src="/logos/branding/Youtube.svg"/> YouTube
                                </span>
                        </a>
                    </li>
                    <li>
                        <a href="https://twitter.com/dans_knaw_nwo" target="_blank">
                                <span class="footer_icons">
                                    <img src="/logos/branding/Twitter.svg"/> Twitter
                                </span>
                        </a>
                    </li>
                </ul>
            </div>
            <div class="col-lg-3 col-md-3 col-sm-6">
                <div class="headless-column">
                    <p>DANS is an institute of <br/>
                        <a href="https://www.knaw.nl/en" target="_blank"><strong>KNAW</strong></a>
                        and
                        <a href="https://www.nwo.nl/en" target="_blank"><strong>NWO</strong></a>
                    </p>
                </div>
            </div>
            <!-- End of row content -->
        </div>
    </div>
</div>
<!-- Additional custom HTML -->
<!-- END of custom footer content -->

<!-- Geomap stuff below -->
<!-- Leaflet -->
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.8.0/dist/leaflet.css"
      integrity="sha512-hoalWLoI8r4UszCkZ5kL8vayOGVae1oxXe/2A4AO6J9+580uKHDO3JdHb7NzwwzK5xr/Fs0W40kiNHxM9vyTtQ==" crossorigin=""/>
<!-- Make sure you put this AFTER Leaflet's CSS -->
<script src="https://unpkg.com/leaflet@1.8.0/dist/leaflet.js"
        integrity="sha512-BB3hKbKWOc9Ez/TAwyWxNXeoV9c1v6FIeYiBieIWkpLjauysF18NzgR1MBNBXf8/KABdlkX68nAhlwcDFLGPCQ==" crossorigin=""></script>
<!-- Clustering-->
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster/dist/MarkerCluster.Default.css" />
<script src="https://unpkg.com/leaflet.markercluster/dist/leaflet.markercluster.js"></script>
<style>
.leaflet-popup-content {
    font-size: 12px; /* needed to fix this */
}
</style>
<script>
// checking the version
let hasJQ = typeof jQuery === 'function'; 
console.log('jQuery' + (hasJQ ? ` version ${jQuery.fn.jquery} loaded.` : ' is not loaded.')); 

$().ready(function() {
    DvAdvSearchExtender.init();

    DvGeoMapCoordinatePreviewer.init();
    // experimental previewer, not yet working
    //DvGeoMapCoordinatePreviewer2.init();

    console.log('start with geomap stuff');
    
    // Find insertion point for the map view div
    // something in #dv-main before #resultsTable and after #resultsCountPaginatorBlock
    let viewInsertionBelow = $('#resultsCountPaginatorBlock');
    // alternative is on the side of the search results, would be logical if that was in sync with the search results
    //let viewInsertionBelow = $('#facetType'); // here it suggests you can 'filter' somehow!

    // Note that this is not always there on that page
    if(viewInsertionBelow === undefined || viewInsertionBelow.length === 0) {
        console.log('No insertion element found');
        return; // Nothing to insert or attach to!
    }

    if (!hasDatasetType()) {
        console.log('No dataset as search type');
        return;
    }

    // We could further restrict display to only specific sub-verses, determined by the url

    // We could also restrict to certain users when logged in, as Beta tester!
    // Note however that the name is not guaranteed to be unique 
    // var userDisplayName = $('#userDisplayInfoTitle').text();

    // TODO: give selection (button or tabview) to switch between map and list view
    // default is the list view
    // when map is selected we need to store it in a session (sessionStorage)
    //  or localstorage
    // and retrieve it when the page is reloaded, 
    // otherwise we would need to select map after every reload/search query change
    // bootstrap nav-tabs or nav-pills could be used for this


    // --- tab stuff
    var tabSelection = createTabSelection();
    tabSelection.insertBefore(viewInsertionBelow);
    //tabSelection.insertAfter($('#resultsCountPaginatorBlock .results-count'));

    // get stored value from local storage or session storage
    // session storage is gone when browser tab or window is closed
    // we only want the selection to survive page reloads because of changes in searching
    var activeTab = sessionStorage.getItem('activeTab'); //localStorage.getItem('activeTab');
    // Maybe? Escape the value for security against injection XSS, better save than sorry
    //activeTab = escape(activeTab)

    var selectedTab = 'list'; // default

    // if activeTab is not null, then show the tab
    if (activeTab) { // we might restrict to values 'list' or 'map' only
        console.log('activeTab: ' + activeTab)
        $('#searchResultsViewTab button[aria-controls="'+activeTab+'"]').tab('show')
        selectedTab = activeTab;
    }
    // Note that 'list' is default


    //$('#searchResultsViewTab button').on('click', function (event) { // BS used button, PF uses a
    $('#searchResultsViewTab a').on('click', function (event) {
        event.preventDefault()
        //$(this).tab('show') // BS
        // For PF: switch class ui-tabs-selected ui-state-active to the li
        //$('#searchResultsViewTab li').removeClass('ui-tabs-selected ui-state-active');
        //$(this).parent().addClass('ui-tabs-selected ui-state-active');

        // do other tab specific stuff here
        console.log('clicked: ' + $(this).attr('id'))

        selectedTab = $(this).attr('aria-controls');
        // store the active tab in local storage
        //localStorage.setItem('activeTab', $(this).attr('aria-controls'));
        sessionStorage.setItem('activeTab', selectedTab);

        updateTabsView();
    })

    // need to fix the hover effect for those PF tabs
    $('#searchResultsViewTab li').hover(function(){
        //console.log('hovered in: ' + $(this).find('a').attr('id'))
        $(this).addClass("ui-state-hover");
    }, function(){
        //console.log('hovered out: ' + $(this).find('a').attr('id'))
        $(this).removeClass("ui-state-hover")
    });

    function updateTabsView() {
        // For PF: switch class ui-tabs-selected ui-state-active to the li
        $('#searchResultsViewTab li').removeClass('ui-tabs-selected ui-state-active');
        $('#searchResultsViewTab li').find('a[aria-controls= "' + selectedTab + '"]').parent().addClass('ui-tabs-selected ui-state-active');

        if (selectedTab === 'map') {
            // do map stuff
            console.log('Map tab selected');
            $('#mapview').show(); 
            $("#resultsTable").hide();
            $(".results-sort-pagination.results-bottom").hide();
            // hide element while keeping layout
            $("#resultsCountPaginatorBlock .results-count").css('visibility', 'hidden');
        } else {
            // do list stuff
            console.log('List tab selected');
            $('#mapview').hide();
            $("#resultsTable").show();
            $(".results-sort-pagination.results-bottom").show();
            // show element while keeping layout
            $("#resultsCountPaginatorBlock .results-count").css('visibility', 'visible');
        }
    }  

    // --- map stuff

    var mapviewDiv = createMapViewDiv();
    mapviewDiv.css("background-color", "#f5f5f5");
    mapviewDiv.css("font-size", "14px"); // somehow font is too small
    mapviewDiv.addClass("border");
    
    mapviewDiv.insertAfter(viewInsertionBelow);
 
    // problems if we do it here    updateTabsView();

    // Initialize map, with OpenStreetMap centered on the Netherlands but showing most of europe
    var map = L.map('geomap').setView([51.505, -0.09], 3);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
        maxZoom: 19,
        attribution: '© OpenStreetMap'
    }).addTo(map);

    // We use clustering for potential large number of points
    // It also handles the case where more points are on the same location
    // https://github.com/Leaflet/Leaflet.markercluster
    var useClustering = true;

    var markers;
    if (useClustering) {
        markers = L.markerClusterGroup();
        // Note we don't use chunckedloading, but retrieve in batches (pages) would be nice
        //markers =L.markerClusterGroup({ chunkedLoading: true, chunkProgress: updateProgressBar });
    } else {
        markers = L.featureGroup();
    }

    map.addLayer(markers);
  
    var baseUrl = getBaseUrl();
    // assume first page, should be retrieved from the url, 
    // or we just always try to retrieve all results up to a certain limit (1000 for now?)
    var start = 0;
    var pageSize = 1000; // default listing pagesize in dataverse is 10, but we could use more, just not more than 1000
    var num_retrieved = 0;
    var searchApiUrl = constructSearchApiUrl(baseUrl)


    doSearchRequest(searchApiUrl);

    // $("#btnSubmit-searchLocation").click(function(){
    //     searchApiUrl = constructSearchApiUrl(baseUrl)
    //     doSearchRequest(searchApiUrl);      
    // });

    updateTabsView(); // must have everything initialized before this call

    function doSearchRequest(extractionUrl) {
        $('#spinner-searchLocation').show();

        //var extractionUrl = "https://archaeology.datastations.nl/api/search?q=*&start="+start+"&per_page="+ pageSize+"&subtree=root&type=dataset&metadata_fields=dansTemporalSpatial:*";
        
        // Getting EASY specific location metadata from its subverse
        const t0 = performance.now();
        $.ajax({url: extractionUrl, 
            success: function(result){
                const t1 = performance.now();
                console.log(`Result of ajax call took ${t1 - t0} milliseconds.`);
                processSearchResult(result)

                // the next page
                start = start + pageSize;
                //$("#btnSubmit-searchLocation").val("Retrieve next "+ pageSize);
            }, 
            error: function(xhr, status, error) {
                console.log("Error: " + error);
            },
            complete: function () {
                $('#spinner-searchLocation').hide();
            }
        });
    }

    function processSearchResult(result) {
        console.log('Total of ' + result.data.total_count + " datasets found");

        extractedFeatures = extractFeatures(result);
        num_retrieved += extractedFeatures.length;
        console.log('Number of features: ' + extractedFeatures.length);

        var markerList = [];

        // Update the map; add the markers corresponding to the features
        // assume points only for now, boundingboxes(rectangles) shoudl be done later
        for (feature of extractedFeatures) {
            // append to leaflet map
            lon = feature.geometry.coordinates[0];
            lat = feature.geometry.coordinates[1];
            //var marker = L.marker([lat,lon]).addTo(map);
            var marker = L.marker([lat, lon]);

            // note that we do not want the DOI url; instead  a direct url to prevent extra redirect like; 
            // https://archaeology.datastations.nl/dataset.xhtml?persistentId=doi:10.17026/dans-x4d-b746
            var dataset_url = baseUrl + '/dataset.xhtml?persistentId=' + feature.properties.id;//feature.properties.url;
            // open in new window when not embedded
            //marker.bindPopup('<a href="' + dataset_url + '"' + ' target="_blank"' + '>' + feature.properties.name + '</a><br>' + feature.properties.id);
            // change current window
            marker.bindPopup('<a href="' + dataset_url + '"' + '>' + feature.properties.name + '</a><br>' 
                + feature.properties.authors + "; " 
                + feature.properties.publication_date + ", <br>" 
                + feature.properties.id);

            //markers.addLayer(marker);
            markerList.push(marker);
        }
        markers.addLayers(markerList);

        // zoom to extend; show all markers but zoomed in as much as possible
        map.fitBounds(markers.getBounds());

        // update controls for download
        $("#result-totals").html(" Retrieved " + num_retrieved + " with a point location"+ " (total number of datasets: " + result.data.total_count + ")");
        //if (num_retrieved > 0) $("#btnSubmit-searchLocation").prop('disabled', false);
        //$("#resultsCountPaginatorBlock .results-count").html(" Retrieved " + num_retrieved + " with a point location"+ " (total number of datasets: " + result.data.total_count + ")");

    }

    function getBaseUrl() {
        console.log('Protocol: ' + window.location.protocol);
        console.log('Port: ' + window.location.port);
        console.log('Host: ' + window.location.hostname);
        console.log('Path: ' + window.location.pathname);

        // construct baseurl
        var baseUrl = window.location.protocol + '//' + window.location.hostname;
        baseUrl += window.location.port.length > 0 ? ':' + window.location.port : '';
        //baseUrl += window.location.pathname; // do not add the path

        console.log('Base URL: ' + baseUrl);

        return baseUrl;
    }

    // Construct search API URL from parts, with query params, paging params etc. etc.
    // Note that in the new frontend SPA the URL could be different and not Solr like... so this should be adapted
    function constructSearchApiUrl(baseUrl) {
        // get the current url
        let url = window.location.href;
        console.log('URL: ' + url);
        // get the search part
        let search = window.location.search;
        console.log('Search: ' + search);
        // get the query params
        let params = new URLSearchParams(search);
        console.log('Params: ' + params);

        // Extract and reuse any fq (filter queries) params to filter on       
        // construct new params object for filter queries
        var newParams = new URLSearchParams();
        // first just add all fq params, copy action
        params.getAll('fq').forEach(fq => newParams.append('fq', fq));
        // get fq0, fq1 etc. (from facet selection) from the params and add to the search query
        for (let i = 0; i <= 9; i++) {
            if (params.has(`fq${i}`)) {
                // map to fq without number, API only can handle that one
                newParams.append('fq', params.get(`fq${i}`));
            }
        }
        console.log('New params: '+ newParams);

        // TODO: use newParams instead of string concatenation below

        var q = '*'; // make sure we have a query, default is '*', API needs it
        if (params.has('q') && params.get('q').length > 0) {
            q = params.get('q');
        }

        // TODO: extract and reuse any sort params to sort on

        var apiUrl = baseUrl + '/api/search' + '?' + 'q=' + q;
        apiUrl += '&type=dataset'; // only datsets when trying to get all datasets
        // But if we want to sync with the current search paging we should uset files and verses if specified
        //var type = params.get('type'); // and the Dataverse default value

        // add the new params to the url
        apiUrl += '&' + newParams.toString();

        // assume first page of root verse, should be retrieved from the url
        //var start = 0;
        //var pageSize = 10; // default pagesize in dataverse is 10, but we could use more
        var subtree = 'root';
        apiUrl += "&start=" + start + "&per_page=" + pageSize + "&subtree=" + subtree;

        // add params specific for archaeology custom metadata
        apiUrl += '&metadata_fields=dansTemporalSpatial:*';

        console.log('New URL: ' + apiUrl);

        return apiUrl;
    }

    function hasDatasetType() {
        // get the current url
        let url = window.location.href;
        console.log('URL: ' + url);
        // get the search part
        let search = window.location.search;
        console.log('Search: ' + search);
        // get the query params
        let params = new URLSearchParams(search);
        console.log('Params: ' + params);

        // check if types is specified
        if (params.has('types') ) {
            var types = params.get('types');
            console.log('Types: ' + types);
            if (types.includes('dataset')) {
                return true;
            } else {
                return false;
            }
        } else {
            return true;
        }
    }
});

// Don't use this; Somehow the tabs do not look bootstrapped?
function createTabSelectionBS() {

    var nav_tabs = $('<ul class="nav nav-tabs" id="searchResultsViewTab" role="tablist">')

    var list_tab = $('<li class="nav-item" role="presentation"><button class="nav-link active" id="list-tab" type="button" role="tab" aria-controls="list" aria-selected="true"> List</button></li>');
    nav_tabs.append(list_tab);

    var list_icon = $(`<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-list-task" viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M2 2.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V3a.5.5 0 0 0-.5-.5zM3 3H2v1h1z"/>
            <path d="M5 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5M5.5 7a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1zm0 4a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1z"/>
            <path fill-rule="evenodd" d="M1.5 7a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5zM2 7h1v1H2zm0 3.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zm1 .5H2v1h1z"/>
          </svg>`);
    list_tab.find('button').prepend(list_icon);
    
    var map_tab = $('<li class="nav-item" role="presentation"><button class="nav-link" id="map-tab" type="button" role="tab" aria-controls="map" aria-selected="false"> Map</button></li>'); 
    var map_icon = $(`<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-map" viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M15.817.113A.5.5 0 0 1 16 .5v14a.5.5 0 0 1-.402.49l-5 1a.5.5 0 0 1-.196 0L5.5 15.01l-4.902.98A.5.5 0 0 1 0 15.5v-14a.5.5 0 0 1 .402-.49l5-1a.5.5 0 0 1 .196 0L10.5.99l4.902-.98a.5.5 0 0 1 .415.103M10 1.91l-4-.8v12.98l4 .8zm1 12.98 4-.8V1.11l-4 .8zm-6-.8V1.11l-4 .8v12.98z"/>
          </svg>`);
    map_tab.find('button').prepend(map_icon);
    nav_tabs.append(map_tab);

    return nav_tabs;
}

function createTabSelection() {
    // PrimeFaces... trying to get look-and-feel right is cumbersome !
    // Note: get hover effect right needed to handle the hover event on the li
    var tabs = $('<div id="searchResultsViewTab" class="ui-tabs ui-widget ui-widget-content ui-corner-all ui-hidden-container ui-tabs-top"></div>')
    // remove border-bottom
    tabs.css('border-bottom', '0px');

    var nav_tabs = $('<ul class="ui-tabs-nav ui-helper-reset ui-widget-header ui-corner-all" role="tablist"></ul>')
    
    var list_tab = $('<li class="ui-tabs-header ui-state-default ui-tabs-selected ui-state-active ui-corner-top" role="tab" tabindex="0" aria-expanded="true" aria-selected="true"><a href="" id="list-tab"  aria-controls="list"> List</a></li>');
    nav_tabs.append(list_tab);
    var list_icon = $(`<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-list-task" viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M2 2.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5V3a.5.5 0 0 0-.5-.5zM3 3H2v1h1z"/>
            <path d="M5 3.5a.5.5 0 0 1 .5-.5h9a.5.5 0 0 1 0 1h-9a.5.5 0 0 1-.5-.5M5.5 7a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1zm0 4a.5.5 0 0 0 0 1h9a.5.5 0 0 0 0-1z"/>
            <path fill-rule="evenodd" d="M1.5 7a.5.5 0 0 1 .5-.5h1a.5.5 0 0 1 .5.5v1a.5.5 0 0 1-.5.5H2a.5.5 0 0 1-.5-.5zM2 7h1v1H2zm0 3.5a.5.5 0 0 0-.5.5v1a.5.5 0 0 0 .5.5h1a.5.5 0 0 0 .5-.5v-1a.5.5 0 0 0-.5-.5zm1 .5H2v1h1z"/>
          </svg>`);
    list_tab.find('a').prepend(list_icon);

    var map_tab = $('<li class="ui-tabs-header ui-state-default ui-corner-top" role="tab" tabindex="0" aria-expanded="false" aria-selected="false"><a href="" id="map-tab" aria-controls="map" aria-selected="false"> Map</a></li>'); 
    nav_tabs.append(map_tab);

    var map_icon = $(`<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="bi bi-map" viewBox="0 0 16 16">
            <path fill-rule="evenodd" d="M15.817.113A.5.5 0 0 1 16 .5v14a.5.5 0 0 1-.402.49l-5 1a.5.5 0 0 1-.196 0L5.5 15.01l-4.902.98A.5.5 0 0 1 0 15.5v-14a.5.5 0 0 1 .402-.49l5-1a.5.5 0 0 1 .196 0L10.5.99l4.902-.98a.5.5 0 0 1 .415.103M10 1.91l-4-.8v12.98l4 .8zm1 12.98 4-.8V1.11l-4 .8zm-6-.8V1.11l-4 .8v12.98z"/>
          </svg>`);
    map_tab.find('a').prepend(map_icon);

    tabs.append(nav_tabs);
    return tabs;
}

// construct the html elements for the mapview
// note that we fixed the height of the map to 480px; was 320px (better for sideview)
function createMapViewDiv() {
    var mapviewDiv = $('<div id="mapview"></div>');

    var controls = $('<p>Geographic location of datasets: </p>');
    controls.append('<span id="result-totals"></span>');
    //controls.append('<input id="btnSubmit-searchLocation" type="submit" value="Start Retrieving" />');

    var spinner = $('<span id="spinner-searchLocation" style="display:none;"></span>');
    //spinner.append('<span class="spinner-border" role="status" style="width: 1.2rem; height: 1.2rem;" ><span class="sr-only">Loading...</span></span>');
    // Note that we use a resource from the dataverse web application
    spinner.append('<span>Loading...</span><img src="/resources/images/ajax-loading.gif" style="width: 1.2em; height: 1.2em;" />');

    controls.append(spinner);
    controls.append('<div id="progress"><div id="progress-bar"></div></div>');

    mapviewDiv.append(controls);
    mapviewDiv.append('<div id="geomap" style="height:480px;"></div>');

    return mapviewDiv;
}


/**
 * Assumes to get a JSON search result from the Dataverse API
 * and this is from the archaeology data station with the dansTemporalSpatial metadata block
 */
const extractFeatures = (result) => {
    const t0 = performance.now();
    var resultFeatureArr = [];

    console.log('Total of items in this page: ' + result.data.items.length);

    $.each(result.data.items, function (key, value) {
        console.log('Processing item: ' + value.name);
        if (typeof value.metadataBlocks !== "undefined" &&
            typeof value.metadataBlocks.dansTemporalSpatial !== "undefined") {
            let authors   = value.authors.map(x => x).join(", ");
            let publication_date = value.published_at.substring(0, 10); // fixed format
            console.log('Authors: ' + authors + '; Publication date: ' + publication_date);

            dansSpatialPoint = value.metadataBlocks.dansTemporalSpatial.fields.find(x => x.typeName === "dansSpatialPoint");
            let title = "<span><a href='" + value.url + "' target='_blank'>" + value.name + "</a></span>";
            let location = ""; //nothing
            // Only points for now!
            if (typeof dansSpatialPoint !== "undefined") {
                dansSpatialPointX = dansSpatialPoint.value[0]["dansSpatialPointX"].value
                dansSpatialPointY = dansSpatialPoint.value[0]["dansSpatialPointY"].value
                // Check the schema of the dansSpatialPointX and dansSpatialPointY
                // dansSpatialPointScheme value = "RD (in m.)", yes a literal string!
                if (dansSpatialPoint.value[0]["dansSpatialPointScheme"].value !== "RD (in m.)") {
                    console.log('Spatial point scheme not in RD, but in: ' + dansSpatialPoint.value[0]["dansSpatialPointScheme"].value);
                    return; // skip this one
                }
                // calculate lat, lon in WGS84, assuming new RD in m.
                latLon = convert(parseFloat(dansSpatialPointX), parseFloat(dansSpatialPointY))
                lat = latLon.lat;
                lon = latLon.lon;
                // The next could be use to show the location in a popup somewhere else
                //location = "<span><a href='http://maps.google.com/maps?z=18&q="+ lat + "," + lon + "' target='_blank'>" + lat  + ", " + lon + "</a></span>";

                // add to the features; geojson format so we can export it later
                const feature = {
                    "type": "Feature",
                    "geometry": {
                        "type": "Point",
                        "coordinates": [lon, lat]
                    },
                    "properties": {
                        "name": value.name,
                        "url": value.url, // note that this is the doi url, with a redirect to the actual dataset, it is persisten so wanted in a json file
                        "authors": authors,
                        "publication_date": publication_date,
                        "id": value.global_id
                    }
                }
                //console.log(feature);
                resultFeatureArr.push(feature);
            }
        }
    });
    const t1 = performance.now();
    console.log(`Call to extractFeatures took ${t1 - t0} milliseconds.`);
    return resultFeatureArr;
}

/** Note that I copied this next convert function from somewhere on the web, 
 * ignoring any errors and not having it validated in any way 
 * copy from https://github.com/glenndehaan/rd-to-wgs84/blob/master/src/index.js
 */
/**
 * Converts the Dutch 'RD' RijksDriehoek coordinate system to standard WGS84 (GPS) coordinates
 *
 * @param x
 * @param y
 * @return 
 */
 const convert = (x, y) => {
    const x0 = 155000.000;
    const y0 = 463000.000;

    const f0 = 52.156160556;
    const l0 = 5.387638889;

    const a01 = 3236.0331637;
    const b10 = 5261.3028966;
    const a20 = -32.5915821;
    const b11 = 105.9780241;
    const a02 = -0.2472814;
    const b12 = 2.4576469;
    const a21 = -0.8501341;
    const b30 = -0.8192156;
    const a03 = -0.0655238;
    const b31 = -0.0560092;
    const a22 = -0.0171137;
    const b13 = 0.0560089;
    const a40 = 0.0052771;
    const b32 = -0.0025614;
    const a23 = -0.0003859;
    const b14 = 0.0012770;
    const a41 = 0.0003314;
    const b50 = 0.0002574;
    const a04 = 0.0000371;
    const b33 = -0.0000973;
    const a42 = 0.0000143;
    const b51 = 0.0000293;
    const a24 = -0.0000090;
    const b15 = 0.0000291;

    const dx = (x - x0) * Math.pow(10, -5);
    const dy = (y - y0) * Math.pow(10, -5);

    // Note that we could precalulate some pow values, like dx_2, dx_3 etc. !

    let df = a01 * dy + a20 * Math.pow(dx, 2) + a02 * Math.pow(dy, 2) + a21 * Math.pow(dx, 2) * dy + a03 * Math.pow(dy, 3);
    df += a40 * Math.pow(dx, 4) + a22 * Math.pow(dx, 2) * Math.pow(dy, 2) + a04 * Math.pow(dy, 4) + a41 * Math.pow(dx, 4) * dy;
    df += a23 * Math.pow(dx, 2) * Math.pow(dy, 3) + a42 * Math.pow(dx, 4) * Math.pow(dy, 2) + a24 * Math.pow(dx, 2) * Math.pow(dy, 4);

    const f = f0 + df / 3600;

    let dl = b10 * dx + b11 * dx * dy + b30 * Math.pow(dx, 3) + b12 * dx * Math.pow(dy, 2) + b31 * Math.pow(dx, 3) * dy;
    dl += b13 * dx * Math.pow(dy, 3) + b50 * Math.pow(dx, 5) + b32 * Math.pow(dx, 3) * Math.pow(dy, 2) + b14 * dx * Math.pow(dy, 4);
    dl += b51 * Math.pow(dx, 5) * dy + b33 * Math.pow(dx, 3) * Math.pow(dy, 3) + b15 * dx * Math.pow(dy, 5);

    const l = l0 + dl / 3600;

    const fWgs = f + (-96.862 - 11.714 * (f - 52) - 0.125 * (l - 5)) / 100000;
    const lWgs = l + (-37.902 + 0.329 * (f - 52) - 14.667 * (l - 5)) / 100000;

    return {
        error: null,
        lat: fWgs,
        lon: lWgs
    }
};

/**
 * This is an example of how to extend the advanced search page
 * with  additional controls or views; via an iframe for instance
 */
const DvAdvSearchExtender = {
    init: function() {
        console.log('DvAdvSearchExtender init');
        
        // Detect if this is the advanced search page
        if (window.location.pathname.endsWith('/search')) {
            console.log('Advanced search page detected');
            // Just to be sure also check for #advancedSearchForm
            if ($('#advancedSearchForm').length > 0) {
                console.log('Advanced search form found');
                this.addExtension();
            } else {
                console.log('Advanced search form not found');
            }
        } else {
            console.log('Not the advanced search page');
        }
    },
    addExtension: function() {
        // add section for the map search
        $('#advancedSearchForm').before('<h3>Explore</h3>');
        $('#advancedSearchForm').before('<p>Search for datasets with external tools</p>');
        // add a button to the advanced search page
        var button = $('<button id="btnMapSearch" class="btn btn-primary">Search on Map</button>');
        button.click(function() {
            console.log('Search on map clicked, could navigate to different page');
            $('#advancedSearchForm').toggle();
        });
        $('#advancedSearchForm').before(button);
        $('#advancedSearchForm').before(`<p>
            This button could navigate to another site 
            or insert/show something on this page. <br/>
            Now it 'toggles' the visibility of the advanced search form!
            </p>`);
        $('#advancedSearchForm').before('<hr>');

        // insert an iframe, but other sites probably do not allow framing
        //var iframe = $('<iframe id="mapSearchFramed" src="/dataverse-previewers-1.4/MapPreview.html"></iframe>'); 
        var iframe = $('<iframe id="mapSearchFramed" src="https://vocabs.datastations.nl/" style="height:480px;width:100%;"></iframe>'); 
        $('#advancedSearchForm').before(iframe);
        $('#advancedSearchForm').before(`<p>
            This iframe could show content from another site, 
            but that should alow framing like our Skosmos site.
            </p>`);
        // Note that I could not get rid of those scrollbars except with scrolling="no"!
        // https://skillapp.co/blog/mastering-iframe-no-scroll-how-to-remove-scrollbars-from-embedded-content-for-a-seamless-user-experience/

        // add a map from OpenStreetMap, without leaflet, but we could use leaflet on other places in the page
        $('#advancedSearchForm').before(`<iframe width="425" height="350" src="https://www.openstreetmap.org/export/embed.html?bbox=4.335222244262696%2C52.076967398325245%2C4.34735655784607%2C52.08255213979543&amp;layer=mapnik&amp;marker=52.07975985640377%2C4.341289401054382" style="border: 1px solid black"></iframe>
           <br/><small><a href="https://www.openstreetmap.org/?mlat=52.079760&amp;mlon=4.341289#map=17/52.079760/4.341289">View Larger Map</a></small>`);


        // add our own query form
        //var form = $('<form id="mapSearchForm"></form>');
        // the form could use the search API ald allow for range query ORring etc.
        // also it could retrieve the facet information and us id differently
        // it could use data pickers and or sliders to select ranges or periods
        // etc.etc.
        // as long as the results have a link to the landing pages, everything works fine


        // Add separator for the next part, the original advanced search form
        $('#advancedSearchForm').before('<hr>');

        $('#advancedSearchForm').before(`<p>
            The next section is the original advanced search 
            that lets search for specific metadata field values. 
            It could be hidden or shown with tabs or buttons.
            </p>`);

    }
};

/**
 * This is a previewer for the geographic coordinates in the metadata of a Dataset
 * It should detect the coordinates and show them on a map 
 * However, this seems to be very problematic with the current working of the metadata tab
 * Also  it is difficult to add the map preview in the right place !
 * So this is a work in progress...
 */
const DvGeoMapCoordinatePreviewer = {
    init: function() {
        console.log('DvGeoMapCoordinatePreviewer init');

        var mapPreviewLocation = null;

        // Detect if we have bounding box metadata
        let metadata_dansSpatialBox = $('#metadata_dansSpatialBox');
        if (metadata_dansSpatialBox.length > 0) {
            console.log('DansSpatialBox metadata found');
            let dansSpatialBoxText = $('#metadata_dansSpatialBox > td').text();
            console.log('DansSpatialBox: ' + dansSpatialBoxText);
            let polygons = DvGeoMapCoordinatePreviewer.extractPolygons(dansSpatialBoxText);
            console.log('Polygons: ' + polygons);
            // bounding boxes in their own map ?????

            //createMapPreviewBoxes
                        // add a map preview
            //this.addMapPreview(metadata_dansSpatialPoint);
            // detect tab selection for datasetForm:tabView
            $('#datasetForm').on('click', function(event) {
                //console.log("target: " + event.target);
                // get text of this dom element
                //console.log("target text: " + event.target.textContent);

                // match 'Temporal and Spatial Coverage'  with regex
                // Note that some parent element will also have this ...
                // could try to narrow it down, luckily we chEck for existence of the metadata_dansSpatialPoint
                // in that createMapPreview function
                let matchTitle = event.target.textContent.match(/\s*Temporal and Spatial Coverage\s*/);
                if (matchTitle !== null) {
                    console.log('Temporal and Spatial Coverage clicked');
                    DvGeoMapCoordinatePreviewer.createMapPreviewBoxes('#metadata_dansSpatialBox', polygons);
                    // if (mapPreviewLocation !== undefined && mapPreviewLocation !== null) {
                    // could do some stuff here
                }

                // Note that we could also add a map preview  at the top of the metadata
                // as a top row of the table. 
                // But now place the map where the coordinates (values) are displayed 
                // has potentially multiple point and or boxes and they are delimited by a <br/>
                // so we can't get a good place to insert the map preview
                // possible we ned to change the content and have each location 
                // in a separate div or span
            });
        } else {
            console.log('DansSpatialBox metadata not found');
        }
        

        // Detect if we have points metadata
        let metadata_dansSpatialPoint = $('#metadata_dansSpatialPoint');
        if (metadata_dansSpatialPoint.length > 0) {
            console.log('DansSpatialPoint metadata found');
            let dansSpatialPointText = $('#metadata_dansSpatialPoint > td').text();
            console.log('DansSpatialPoint: ' + dansSpatialPointText);

            // because we extract the coordinates from the text, we don't need to do a search request, 
            // and we can simply also display drafts etc. 
            // The initial idea was to replace the text with coordinates as links 
            // to external maps or even with an iframe

            let points = DvGeoMapCoordinatePreviewer.extractPoints(dansSpatialPointText);
            console.log('Points: ' + points);
            
            // add a map preview
            //this.addMapPreview(metadata_dansSpatialPoint);
            // detect tab selection for datasetForm:tabView
            $('#datasetForm').on('click', function(event) {
                //console.log("target: " + event.target);
                // get text of this dom element
                //console.log("target text: " + event.target.textContent);

                // match 'Temporal and Spatial Coverage'  with regex
                // Note that some parent element will also have this ...
                // could try to narrow it down, luckily we chEck for existence of the metadata_dansSpatialPoint
                // in that createMapPreview function
                let matchTitle = event.target.textContent.match(/\s*Temporal and Spatial Coverage\s*/);
                if (matchTitle !== null) {
                    console.log('Temporal and Spatial Coverage clicked');
                    mapPreviewLocation = DvGeoMapCoordinatePreviewer.createMapPreview('#metadata_dansSpatialPoint', points);
                    // if (mapPreviewLocation !== undefined && mapPreviewLocation !== null) {
                    // could do some stuff here
                }

                // Note that we could also add a map preview  at the top of the metadata
                // as a top row of the table. 
                // But now place the map where the coordinates (values) are displayed 
                // has potentially multiple point and or boxes and they are delimited by a <br/>
                // so we can't get a good place to insert the map preview
                // possible we ned to change the content and have each location 
                // in a separate div or span
            });
        } else {
            console.log('DansSpatialPoint metadata not found');
        }
    },
    extractPoints: function(text) {
        let points = [];
        // TODO add original coordinates to the points, could put that in pop-up text per marker...
        // Note that we know there is a newline separation we will use the regexp matchAll
        // extract Longitude/latitude (degrees)'
        let dansSpatialPointDegreesMatches = text.matchAll(/(\d+\.?\d+)\s*(\d+\.?\d+) Longitude\/latitude \(degrees\)/g);
        for (const match of dansSpatialPointDegreesMatches) {
            console.log('Lon/Lat (degrees) coordinates found');
            let lon = match[1];
            let lat = match[2];
            console.log('Lat: ' + lat + '; Lon: ' + lon);
            points.push({"coordinates":[lat, lon], title: `Lon/Lat (degrees): ${lon}, ${lat}`});
        }
        // try matching RD
        let dansSpatialPointRDMatches = text.matchAll(/(\d+\.?\d+)\s*(\d+\.?\d+) RD \(in m\.\)/g);
        for (const match of dansSpatialPointRDMatches) {
            console.log('RD (in m.) coordinates found');
            // convert to lat, lon
            let latLon = convert(match[1], match[2]);
            console.log('Lat: ' + latLon.lat + '; Lon: ' + latLon.lon);
            points.push({"coordinates":[latLon.lat, latLon.lon], "title": `RD (in m.): ${match[1]}, ${match[2]}`});
        }
        return points;
    },
    extractPolygons: function(text) {
        // for DANS arch. we have bounding boxes, but we handle them as polygons
        let polygons = [];
        let dansSpatialBoxDegreesMatches = text.matchAll(/(\d+\.?\d+)\s*(\d+\.?\d+)\s*(\d+\.?\d+)\s*(\d+\.?\d+) Longitude\/latitude \(degrees\)/g);
        for (const match of dansSpatialBoxDegreesMatches) {
            console.log('Lon/Lat (degrees) coordinates found');
            let dansSpatialBoxNorth = match[1];
            let dansSpatialBoxEast = match[2];
            let dansSpatialBoxSouth = match[3];
            let dansSpatialBoxWest = match[4];

            // initialize the feature with the bounding box, WGS8 default
            var latLon_NE = {lat: parseFloat(dansSpatialBoxNorth), lon: parseFloat(dansSpatialBoxEast)};
            var latLon_SW = {lat: parseFloat(dansSpatialBoxSouth), lon: parseFloat(dansSpatialBoxWest)};

            polygons.push({"coordinates": [[latLon_SW.lat, latLon_SW.lon],
                                    [latLon_NE.lat, latLon_SW.lon],
                                    [latLon_NE.lat, latLon_NE.lon],
                                    [latLon_SW.lat, latLon_NE.lon],
                                    [latLon_SW.lat, latLon_SW.lon]], 
                                    "title": `Lon/Lat (degrees): ${dansSpatialBoxNorth}, ${dansSpatialBoxEast}, 
                                    ${dansSpatialBoxSouth}, ${dansSpatialBoxWest}`});
        }

        // try matching RD
        let dansSpatialBoxRDMatches = text.matchAll(/(\d+\.?\d+)\s*(\d+\.?\d+)\s*(\d+\.?\d+)\s*(\d+\.?\d+) RD \(in m\.\)/g);
        for (const match of dansSpatialBoxRDMatches) {
            console.log('RD (in m.) coordinates found');
            let dansSpatialBoxNorth = match[1];
            let dansSpatialBoxEast = match[2];
            let dansSpatialBoxSouth = match[3];
            let dansSpatialBoxWest = match[4];

            var latLon_NE = {lat: parseFloat(dansSpatialBoxNorth), lon: parseFloat(dansSpatialBoxEast)};
            var latLon_SW = {lat: parseFloat(dansSpatialBoxSouth), lon: parseFloat(dansSpatialBoxWest)};
            // convert to WGS84
            latLon_NE = convert(latLon_NE.lon, latLon_NE.lat);
            latLon_SW = convert(latLon_SW.lon, latLon_SW.lat);
            polygons.push({"coordinates": [[latLon_SW.lat, latLon_SW.lon],
                                    [latLon_NE.lat, latLon_SW.lon],
                                    [latLon_NE.lat, latLon_NE.lon],
                                    [latLon_SW.lat, latLon_NE.lon],
                                    [latLon_SW.lat, latLon_SW.lon]], 
                                    "title": `RD (in m.): ${dansSpatialBoxNorth}, ${dansSpatialBoxEast}, 
                                    ${dansSpatialBoxSouth}, ${dansSpatialBoxWest}`});
        }

        return polygons;
    },
    createMapPreview: function(id, points) {
        //$(id).find('#mapPreview').remove(); // then with every click we remove adn reset the map preview
        // If I just return when it is there
        if ($(id).find('#mapPreview').length > 0 ) {
            console.log('Map preview already exists');
            return null; // return  if found, nothing to do
        }

        // create a map preview
        let mapPreview = $('<div id="mapPreview"></div>');
        $(id).append(mapPreview);

        // add a map from OpenStreetMap, without leaflet, but we could use leaflet on other places in the page
        //mapPreview.append(`<iframe width="425" height="350" 
        //src="https://www.openstreetmap.org/export/embed.html?bbox=4.335222244262696%2C52.076967398325245%2C4.34735655784607%2C52.08255213979543&amp;layer=mapnik&amp;
        //marker=${lat}%2C${lon}" style="border: 1px solid black"></iframe>
        //   <br/><small><a href="https://www.openstreetmap.org/?mlat=${lat}&amp;mlon=${lon}#map=17/${lat}/${lon}" target="_blank">View Larger Map</a></small>`);
        //
        //mapPreview.append(`<br/><small><a href="https://www.openstreetmap.org/?mlat=${lat}&amp;mlon=${lon}#map=17/${lat}/${lon}" target="_blank">View Larger Map</a></small>`);
        
        // use leaflet to show the map
        let mapDiv = $('<div id="geomapPreviewLocation" style="width:320px;height:240px;min-height:240px;border:1px solid;margin-bottom:5px;"></div>');
        mapPreview.append(mapDiv);
        // create a leaflet map
        let mapPreviewLocation = L.map('geomapPreviewLocation').setView([52.0, 5.0], 12);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
                '<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
                'Imagery © <a href="https://www.openstreetmap.org/">OpenStreetMap</a>'
        }).addTo(mapPreviewLocation);

        let markers = [];
        // get each point from points
        for (let i = 0; i < points.length; i++) {
            let point = points[i];
            console.log('Point: ' + point.coordinates);
            let lat = point.coordinates[0];
            let lon = point.coordinates[1];
            // add a marker for each point
            let marker = L.marker([lat, lon])
                .bindPopup(point.title);
            markers.push(marker);
        }
        const featureGroup = L.featureGroup(markers).addTo(mapPreviewLocation);
        // zoom to extend; show all markers but zoomed in as much as possible
        mapPreviewLocation.fitBounds(featureGroup.getBounds(), {padding: [20, 20]});
        mapPreviewLocation.invalidateSize();
        // since all this is part of (animated) bootstrap (PrimeFaces) stuff for the panel this is on
        // we need to trigger a resize event to get the map to show correctly
        // When incorrect, just a little manual browser window resizing seems to fix it....
        // Now to fix it we need to do the invalidateSize  with a delay !    
        setTimeout(() => {
            mapPreviewLocation.invalidateSize();
            mapPreviewLocation.fitBounds(featureGroup.getBounds());
            // make the bounds a bit wider
            mapPreviewLocation.fitBounds(featureGroup.getBounds(), {padding: [20, 20]});
            // window.dispatchEvent(new Event('resize'));
        }, 300); // slight delay helps with animations/layout shifts

        return mapPreviewLocation;

        // pDiv = $('<a href="#" data-toggle="popover" title="Popover Header" data-trigger="hover" data-content="Some content inside the popover">Toggle popover</a>');
        // mapPreview.append(pDiv);
        // pDiv.popover({
        //     html: true,
        //     content: function () {
        //         return $('#geomapPreviewLocation').html();
        //     }
        // });  
 
    },
    createMapPreviewBoxes: function(id, polygons) {
        const preview_id_prefix = 'boxes' + '_';
        //$(id).find('#mapPreview').remove(); // then with every click we remove adn reset the map preview
        // If I just return when it is there
        if ($(id).find('#' + preview_id_prefix + 'mapPreview').length > 0 ) {
            console.log('Map preview already exists');
            return null; // return  if found, nothing to do
        }

        // create a map preview
        let mapPreview = $('<div id="' + preview_id_prefix + 'mapPreview"></div>');
        $(id).append(mapPreview);

        // Use different color for the marker balloon (icon) 
        // if we have polygons, which is bounding box in simplest case
        let redIcon = L.icon({
            iconUrl: 'https://cdn.rawgit.com/pointhi/leaflet-color-markers/master/img/marker-icon-2x-red.png',
            shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/images/marker-shadow.png',
            iconSize: [25, 41],
            iconAnchor: [12, 41],
            popupAnchor: [1, -34],
            shadowSize: [41, 41]
        });

        // add a map from OpenStreetMap, without leaflet, but we could use leaflet on other places in the page
        //mapPreview.append(`<iframe width="425" height="350" 
        //src="https://www.openstreetmap.org/export/embed.html?bbox=4.335222244262696%2C52.076967398325245%2C4.34735655784607%2C52.08255213979543&amp;layer=mapnik&amp;
        //marker=${lat}%2C${lon}" style="border: 1px solid black"></iframe>
        //   <br/><small><a href="https://www.openstreetmap.org/?mlat=${lat}&amp;mlon=${lon}#map=17/${lat}/${lon}" target="_blank">View Larger Map</a></small>`);
        //
        //mapPreview.append(`<br/><small><a href="https://www.openstreetmap.org/?mlat=${lat}&amp;mlon=${lon}#map=17/${lat}/${lon}" target="_blank">View Larger Map</a></small>`);
        
        // use leaflet to show the map
        let mapDiv = $('<div id="' + preview_id_prefix + 'geomapPreviewLocation" style="width:320px;height:240px;min-height:240px;border:1px solid;margin-bottom:5px;"></div>');
        mapPreview.append(mapDiv);
        // create a leaflet map
        let mapPreviewLocation = L.map('' + preview_id_prefix + 'geomapPreviewLocation').setView([52.0, 5.0], 12);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            maxZoom: 18,
            attribution: 'Map data &copy; <a href="https://www.openstreetmap.org/">OpenStreetMap</a> contributors, ' +
                '<a href="https://creativecommons.org/licenses/by-sa/2.0/">CC-BY-SA</a>, ' +
                'Imagery © <a href="https://www.openstreetmap.org/">OpenStreetMap</a>'
        }).addTo(mapPreviewLocation);

        let markers = [];
        // get each point from points
        for (let i = 0; i < polygons.length; i++) {
            let polygon = polygons[i];
            console.log('polygon: ' + polygon.coordinates);

            // calculate center of the polygon (could be bounding box)
            // Note that we only use the first polygon, there could be more in the future
            let p = L.polygon(polygon.coordinates, {color: 'red'});

            // add the polygon to the map
            //p.addTo(mapPreviewLocation);
            markers.push(p); // markers name is misleading , 
            // should be features or we put the polygons in different layer?

            // 'red' marker at center
            let bounds = p.getBounds();
            let center = bounds.getCenter();
            lon = center.lng;
            lat = center.lat;

            // add a marker for each polygon
            //let marker = L.marker([lat, lon])
            //    .bindPopup(polygon.title);
            let marker = L.marker([lat, lon], {icon: redIcon})
                .bindPopup(polygon.title);

            markers.push(marker);
        }
        const featureGroup = L.featureGroup(markers).addTo(mapPreviewLocation);
        // zoom to extend; show all markers but zoomed in as much as possible
        mapPreviewLocation.fitBounds(featureGroup.getBounds(), {padding: [20, 20]});
        mapPreviewLocation.invalidateSize();
        // since all this is part of (animated) bootstrap (PrimeFaces) stuff for the panel this is on
        // we need to trigger a resize event to get the map to show correctly
        // When incorrect, just a little manual browser window resizing seems to fix it....
        // Now to fix it we need to do the invalidateSize  with a delay !    
        setTimeout(() => {
            mapPreviewLocation.invalidateSize();
            mapPreviewLocation.fitBounds(featureGroup.getBounds());
            // make the bounds a bit wider
            mapPreviewLocation.fitBounds(featureGroup.getBounds(), {padding: [20, 20]});
            // window.dispatchEvent(new Event('resize'));
        }, 300); // slight delay helps with animations/layout shifts

        return mapPreviewLocation;
 
    }

};

// experimenting with popovers
const DvGeoMapCoordinatePreviewer2 = {
    init: function() {
        console.log('DvGeoMapCoordinatePreviewer2 init');

        //$('#datasetForm:editMetadata').on('click', function(event) {


        // need to look at every click event and then decide if we need to do something
        $("*").on('click', $.proxy(function() {
            // get the event target
            var target = $(event.target);
            // check if it is that collapsed element
            if (target  && target.hasClass('collapsed')) {
                console.log('Collapsed element clicked');
                console.log('Text: ' + target.text());
                if (target.text().trim() === 'Temporal and Spatial Coverage') {
                    console.log('Edit metadata clicked');
                    // find the insertion points for the map preview
                    $('#metadata_dansSpatialPoint').each(function () {
                        // TODO find the value of the dansSpatialPoint 
                        let pButton = $('<button type="button" class="btn btn-info" id="popoverButton">Click me for popover</button>');
                    
                        $(this).append(pButton);
                        // Initialize popover
                        $('#popoverButton').popover({
                            title: '<strong>Popover Title</strong>',
                            content: '<p>This is some <strong>HTML</strong> content inside the popover.</p>',
                            html: true
                        });
                        // Add elements when popover is shown
                        $('#popoverButton').on('shown.bs.popover', function () {
                            // Find the popover content
                            var popoverContent = $(this).data('bs.popover').$tip.find('.popover-content');
                            // Add new content/elements (e.g., a new paragraph)
                            popoverContent.append('<p>This is some dynamically added content!</p>');
                            // You can also add other elements or do more actions
                            popoverContent.append('<button class="btn btn-success">New Button</button>');
                        });
                    });
                }
            }
            /*
            var isEditMetadata = $('.collapsed').filter(function() {
                return ($(this).text() === 'Temporal and Spatial Coverage');
            });
            if (!isEditMetadata) {
                return;
            }
            console.log('Edit metadata clicked');
            // find the insertion points for the map preview
            $('#metadata_dansSpatialPoint').each(function () {
                // TODO find the value of the dansSpatialPoint 
                let pButton = $('<button type="button" class="btn btn-info" id="popoverButton">Click me for popover</button>');
            
                $(this).append(pButton);
                // Initialize popover
                $('#popoverButton').popover({
                    title: '<strong>Popover Title</strong>',
                    content: '<p>This is some <strong>HTML</strong> content inside the popover.</p>',
                    html: true
                });
                // Add elements when popover is shown
                $('#popoverButton').on('shown.bs.popover', function () {
                    // Find the popover content
                    var popoverContent = $(this).data('bs.popover').$tip.find('.popover-content');
                    // Add new content/elements (e.g., a new paragraph)
                    popoverContent.append('<p>This is some dynamically added content!</p>');
                    // You can also add other elements or do more actions
                    popoverContent.append('<button class="btn btn-success">New Button</button>');
                });
            });
            */
        }, this));
        // find the insertion points for the map preview
        // this time on the input form

    },
    createMapPreview: function(id, lat, lon) {
    }
};

</script>